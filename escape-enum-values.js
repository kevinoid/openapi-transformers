#!/usr/bin/env node
/**
 * Script to escape string enum values appropriately for C# string literals
 * when code will be generated by Autorest, since it currently does not.
 *
 * https://github.com/Azure/autorest/issues/3371
 *
 * @copyright Copyright 2019-2021 Kevin Locke <kevin@kevinlocke.name>
 * @license MIT
 */

'use strict';

const OpenApiTransformerBase = require('openapi-transformer-base');
const { readFile, writeFile } = require('./lib/file-utils.js');

const escapeStringSymbol = Symbol('escapeString');

function makeEscapeString(lang) {
  let charToEscape = {
    '\0': '\\0',
    '\x07': '\\a',
    '\b': '\\b',
    '\t': '\\t',
    '\n': '\\n',
    '\v': '\\v',
    '\f': '\\f',
    '\r': '\\r',
    "'": "\\'",
    '"': '\\"',
    '\\': '\\\\',
  };
  // Escape control characters for all languages for readability
  let charRange = '\0-\x1F\x7F';

  let toAstralEscape, toCodeEscape;
  switch (lang) {
    case 'csharp':
      // https://docs.microsoft.com/en-us/dotnet/csharp/language-reference/language-specification/lexical-structure#string-literals
      charRange += '\n\r"\\\\\x85\u2028\u2029';
      // Note: Although \x can be shorter, must be careful to provide 4
      // digits when next character is hex digit.  Use \u for consistency.
      toCodeEscape =
        (c) => `\\u${c.charCodeAt(0).toString(16).padStart(4, '0')}`;
      toAstralEscape = (code) => `\\U${code.toString(16).padStart(8, '0')}`;
      break;

    case 'go':
      // https://golang.org/ref/spec#String_literals
      charRange += '\n"\\\\';
      toCodeEscape = (c) => {
        const code = c.charCodeAt(0);
        return code <= 0xFF ? `\\x${code.toString(16).padStart(2, '0')}`
          : `\\u${code.toString(16).padStart(4, '0')}`;
      };
      toAstralEscape = (code) => `\\U${code.toString(16).padStart(8, '0')}`;
      break;

    case 'java':
      // https://docs.oracle.com/javase/specs/jls/se8/html/jls-3.html#jls-3.10.5
      charRange += '\n"\\\\';
      delete charToEscape['\0'];
      delete charToEscape['\x07'];
      delete charToEscape['\v'];
      toCodeEscape =
        (c) => `\\u${c.charCodeAt(0).toString(16).padStart(4, '0')}`;
      break;

    case 'nodejs':
    case 'typescript':
      // https://www.ecma-international.org/ecma-262/6.0/#sec-literals-string-literals
      // Note: AutoRest currently produces single-quoted strings, but the
      // bloat from extra quoting is minor compared to risk.
      charRange += '\n"\'\\\\';
      delete charToEscape['\x07'];
      toCodeEscape = (c) => {
        const code = c.charCodeAt(0);
        return code <= 0xFF ? `\\x${code.toString(16).padStart(2, '0')}`
          : `\\u${code.toString(16).padStart(4, '0')}`;
      };
      toAstralEscape = (code) => `\\u{${code.toString(16)}}`;
      break;

    case 'php':
      // https://www.php.net/manual/en/language.types.string.php
      // FIXME: Does AutoRest produce single- or double-quoted strings?
      // Can't test due to https://github.com/Azure/autorest/issues/3372
      charRange += '\n"\\\\';
      delete charToEscape['\x07'];
      delete charToEscape['\b'];
      charToEscape['\x1B'] = '\\e';
      toCodeEscape = (c) => {
        const code = c.charCodeAt(0);
        return code <= 0xFF ? `\\x${code.toString(16).padStart(2, '0')}`
          : `\\u{${code.toString(16)}}`;
      };
      toAstralEscape = (code) => `\\u{${code.toString(16)}}`;
      break;

    case 'python':
      // https://docs.python.org/3/reference/lexical_analysis.html#string-and-bytes-literals
      // Note: AutoRest currently produces single-quoted strings, but the
      // bloat from extra quoting is minor compared to risk.
      charRange += '\n"\'\\\\';
      toCodeEscape = (c) => {
        const code = c.charCodeAt(0);
        return code <= 0xFF ? `\\x${code.toString(16).padStart(2, '0')}`
          : `\\u${code.toString(16).padStart(4, '0')}`;
      };
      toAstralEscape = (code) => `\\U${code.toString(16).padStart(8, '0')}`;
      break;

    case 'ruby':
      // Note: AutoRest currently produces single-quoted strings.
      // Can only escape ' and \
      charRange = "'\\\\";
      charToEscape = {};
      charToEscape['\x1B'] = '\\e';
      toCodeEscape = (c) => c;
      break;

    default:
      throw new RangeError(`Unrecognized language '${lang}'`);
  }

  function replaceAstral(pair) {
    const high = pair.charCodeAt(0);
    const low = pair.charCodeAt(1);
    const code = (high - 0xD800) * 0x400 + low - 0xDC00 + 0x10000;
    return toAstralEscape(code);
  }
  function replaceChar(c) {
    return charToEscape[c] || toCodeEscape(c);
  }
  const charPattern = new RegExp(`[${charRange}]`, 'g');
  return function escapeString(str) {
    if (!str || typeof str !== 'string') {
      return str;
    }

    const charEscaped = str.replace(charPattern, replaceChar);
    const astralEscaped = !toAstralEscape ? charEscaped
      : charEscaped.replace(/[\uD800-\uDBFF][\uDC00-\uDFFF]/g, replaceAstral);
    return astralEscaped;
  };
}

function escapeInSchema(schema, escapeString) {
  const xMsEnum = schema['x-ms-enum'];
  if (!xMsEnum || schema.type !== 'string') {
    // Schema won't generate a class/enum with string values
    return schema;
  }

  const xMsEnumValues = xMsEnum.values;
  if (xMsEnumValues) {
    // generator uses .x-ms-enum.values instead of .enum
    return {
      ...schema,
      'x-ms-enum': {
        ...xMsEnum,
        values: xMsEnumValues.map((xMsEnumValue) => ({
          ...xMsEnumValue,
          value: escapeString(xMsEnumValue.value),
        })),
      },
    };
  }

  return {
    ...schema,
    enum: schema.enum.map(escapeString),
  };
}

class EscapeEnumValuesTransformer extends OpenApiTransformerBase {
  constructor(options) {
    super();

    const { language } = options;
    const typeofLanguage = typeof language;
    switch (typeofLanguage) {
      case 'string':
        this[escapeStringSymbol] = makeEscapeString(language);
        break;
      case 'function':
        this[escapeStringSymbol] = language;
        break;
      default:
        throw new TypeError(
          `options.language must be a string or function, got ${
            typeofLanguage}`,
        );
    }
  }

  transformSchema(schema) {
    return escapeInSchema(
      super.transformSchema(schema),
      this[escapeStringSymbol],
    );
  }

  transformParameter(parameter) {
    return escapeInSchema(
      super.transformParameter(parameter),
      this[escapeStringSymbol],
    );
  }
}

module.exports = EscapeEnumValuesTransformer;

function escapeEnumValues(spec, options) {
  const transformer = new EscapeEnumValuesTransformer(options);
  return transformer.transformOpenApi(spec);
}

function main(args, options, cb) {
  const usage = `Usage: ${args[1]} --language <lang> [input] [output]\n`;

  const firstArg = args[2];
  if (firstArg === '--help') {
    options.stdout.write(usage);
    cb(0);
    return;
  }

  if (firstArg !== '--language') {
    options.stderr.write(`Error: First argument must be --language.\n${usage}`);
    cb(1);
    return;
  }

  if (args.length < 3) {
    options.stderr.write(`Error: --language requires an argument.\n${usage}`);
    cb(1);
    return;
  }

  const language = args[3];
  const inputPathOrDesc = !args[4] || args[4] === '-' ? 0 : args[4];
  const outputPathOrDesc = !args[5] || args[5] === '-' ? 1 : args[5];

  // eslint-disable-next-line promise/catch-or-return
  readFile(inputPathOrDesc, { encoding: 'utf8' })
    .then((specStr) => escapeEnumValues(
      JSON.parse(specStr),
      { language },
    ))
    .then((spec) => writeFile(
      outputPathOrDesc,
      JSON.stringify(spec, undefined, 2),
    ))
    .then(
      () => cb(0),  // eslint-disable-line promise/no-callback-in-promise
      (err) => {
        options.stderr.write(`${err.stack}\n`);
        cb(1);  // eslint-disable-line promise/no-callback-in-promise
      },
    );
}

if (require.main === module) {
  // This file was invoked directly.
  main(process.argv, process, (exitCode) => {
    process.exitCode = exitCode;
  });
}
